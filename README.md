# <span id="brief">简介</span>

## <span id="whats_fa_language">FA Language是什么？</span>

<big>`FA Language（FA 语言）语言[目前]是[一种][粗制滥造的][伪][函数式]语言，目前使用C#语言实现，争取能够早日自举（XD）。`</big>



准确地说，截止到目前，作者也不确定到底为什么要做FA语言，更不确定到底应该归为哪一类，可以说完全是为了“做”而做（其实是编译原理的课程设计，default thesis个人不太喜欢，就决定这个了。只能按照函数式语言来约束她。可能以后FA语言会成为其他类型的吧？



不幸的是，其执行只能够以interactive的形式，可以说，FA语言目前还是一个玩具。



## <span id="interpreted_or_compiled">解释？编译？</span>

就目前来说，FA语言还是一种解释执行的语言。



不过更准确地说，编译还是解释取决于FA语言的开发进展。也就是说，在以后，FA语言可能有编译和解释两种形式，当然也不排除引入虚拟机。



### <span id="when_interpret_and_compile">那么什么时候解释，什么时候编译呢？</span>

如果FA语言的某个版本处于Developing（开发）阶段（也就意味着在此阶段将可能引入新功能，或有一些改进），那么此版本将只提供解释执行方式。一旦确定此版本[比较]成熟了，那么将在后续引入编译执行方式。



**由于作者水平有限，且编译执行的实现难度在主观上要大于解释执行，所以作者只能  *尽可能地*  提供编译执行方式，所以也意味着，作者在（在新的Developing version中添加新功能/添加新特性/做优化）和（把上一个Developing Version的解释执行版本做成编译执行版本）之间，作者选择前者的可能性更大**。<small>在前面的一句话中，为了更清晰地表明关系，使用了中文小括号。</small>



# <span id="principle">原则</span>

由于需求不明确（XD），FA语言也没有什么非常明确的原则。像Perl的“做一件事不只有一种方法”和Python的“做一件事只有一种方法”这样的原则是不存在的。或许没有原则就是FA语言最大的原则吧。FA语言可能会因为这个原则茁壮成长，也可能突然暴毙，谁知道呢……



# <span id="syntax">语法</span>

## <span id="before_grammar">讨论之前</span>

在[简介](#brief)中，提到FA是一种函数式语言，所以在最初阶段，先按照函数式语言来设计之。在后期，**很**有可能会偏离这一方向。



## <span id="object_in_FA">关于对象</span>

虽说是函数是语言，但是仍然舍不得对象……不过在最开始的版本中，并不会引入对象这一特性，而只是保留了一个最根对象——FA对象。他将是以后所有对象（如果有的话）的父对象。



## <span id="grammar_form">形式</span>

在FA语言中，一条语句大概长得像这样：



`<func1> [<param1>,param2[,param3[,param4]]] `

尖括号中是必须有的，而方括号中的是可选的内容。

上面的语句把`param1`，`param2`，`param3`和`param4`作为参数来执行`<func1>`，参数是可选的，但是必须要确保至少有一个参数



既然在初期设定是函数式语言，那么至少就按照函数式语言来设计。很多在PP或OOP语言中的常见操作在FA语言中都或多或少显得诡异。不过一部分可以在Haskell中或LISP中找到相似的设计。一个显著的特征就是**一切皆函数**。例如`+`是一个函数。而更有意思的是，数字，例如`123`，也是函数，是一个没有参数的函数。

下面举一些例子：

- 计算`1 + 2`的值，那么就要写作

  ```
  + 1, 2
  ```

  在上面的语句中，`+`是一个函数，在这个函数的调用中，它接受两个参数，这两个参数分别是两个函数`1`和`2`。

- 计算`1 + 2 - 3`

  ```
  - (+ 1, 2), 3
  ```

  这样看起来似乎有些诡异，或者说不可理喻，不过放在函数式语言中，就可以理解了。在这里，屈服于优先级，使用了括号。

- 再来一个更复杂的例子：计算2+4*(6-3)

  ```
  + 2, (* 4, (- 6, 3))
  ```



## <span id="basic_grammar">基本语法</span>

### 注释

在当前的版本中，由于是interactive执行，所以只支持单行注释，也就是在语句后面的注释。

- 单行注释：以`//`开头，后面的内容均为注释，注释不被编译器/解释器所接受/处理。



### 语句

#### 单语句

在FA语言中，推崇“一行做一件事”。尽可能地在一行之内实现要做的操作。这也就意味着，在这样的情况下，行结束符将是语句的结束。



#### 复合语句

虽然FA语言推崇单语句，但是很多复杂的运算很难在单行的语句内完成，所以FA也可以（理所应当地）使用复合语句，也就是使用多行来表达一条语句。需要注意的是，复合部分需要使用`{}`括起来。

*示例：*

```
size_of_square l, w => { <line1>, 
                    <line2>,
                    <line3>,
                    ...
                    }
```

在上面的例子中，定义了一个用来求矩形面积的函数`size_of_square`，它接受两个参数`l`和`w`。有关函数的章节请见[这里](#variable_and_function).虽然在这个例子中，使用了缩进来进行对齐，但是需要注意的是这并不是必须的。因为在复合语句中，只有花括号才是语句开始和结束的标志，而逗号是语句间的分隔。那么这样就意味着我们可以把多个语句放在一行中。

*示例：*

```
size_of_square l, w => { <line1>, <line2>, <line3>, ... }
```



#### 间隔符

间隔符`,`是用来间隔语句元素的，例如形参和实参中多个变量之间的分隔，以及复合语句中多个语句之间的分隔。下面的语句是合法的：

```
<func1> <param1>, <param2>, <func2> <param3>, <func3> <param4>, <param5>
```

但是这样看起来可能令人困惑，因为我们可能会怀疑，到底哪一个是参数，哪一个是函数。虽然解释器可以区分，但是人类很难做到，尤其是代码量变得十分巨大的时候，我们很难记住一些变量以及函数的名字。所以作者并不推崇这种写法。我们可以在需要区分的地方借助小括号的帮助。

*示例：*

```
（<func1> <param1>, <param2>), (<func2> <param3>), (<func3> <param4>, <param5>)
```

需要注意的是，在这种写法下，运算的值为最后一个运算的值。

*示例：*

```
a => 4 + 8, 3 - 4, 1 + 1    // a的值为2
```



### 数据类型

#### <span id="numbers">数</span>

在FA语言中，数也作为函数来出现。在默认情况下，数的类型为实数，除非另行约定。



##### <span id="typys_of_numbers">数的类型</span>

在FA语言中，支持实数和复数，其中实数支持整型和实型（浮点型）



- 实数
  - 实型：带小数点的实数均为实型。类型名为`real`。
  - 整型：不带小数点的实数均为整型。类型名为`int`。

- 复数

复数带约定很简单

```
<real>i<imag>
```

在上面的约定中，`<real>`为实部，`<imag>`为虚部，实部和虚部均为实数（可以是浮点型也可以是整型，但是最终都将以浮点型来计算），在实部和虚部之间使用小写字母`i`来分隔。复数的类型名为`imag`。



##### 类型转换

除非运算符处理的数的类型不同，否则不改变数的类型。例如`5 + 9`，运算符两边都是整型，那么结果也为整型。而如果是`5.0 + 9`，则把两边都转成实型，最后返回也是实型。



- 强制类型转换

  下列内建函数可以执行强制类型转换：

  - `int <param>`：将param转换成整型。如果`<param>`为实型，那么将返回`<param>`约去小数部分后的整数值（例如`int 3.4`和`int 3.9`都将返回`3`）。
  - `real <param>`：将param转换成实型。如果`<param>`是虚数，那么出现错误。
  - `imag <param>`：将param转换成虚数。如果`<param`>不是imag类型，那么将首先把`<param>`转换成`<real>`类型，再将其作为虚数的实部返回。



#### None 类型

None类型就是None类型。



#### 布尔类型

布尔类型为`bool`。布尔类型只能有两个取值，`true`和`false`，布尔类型可以和整型相互转换。对`0`做布尔强制类型转换则得到`false`，任何非零值都将转换成`true`。而对`true`做到整型的强制转换则得到1，对`false`做到整型的强制类型转换则得到0。

*示例：*

- 将2转换成布尔型：

  ```
  bool 2  // 得到true
  ```

- 将true转换成整型：

  ```
  int true  // 得到1
  ```



#### 混合类型：列表、字符串和元组

##### 列表

列表也就是数组，或者说是变长数组，在列表中，必须存放相同类型的数据。列表的有如下的形式：

```
[<obj1>, <obj2>, ...]
```

*示例：*

- [1, 2, 3] 定义了一个包含整型数1，2和3的列表
- [3i5, -1i6.7,0i0]定义了一个包含三个复数的列表
- [true, false, false]定义了一个包含三个布尔型的列表

##### 列表上的运算

1. 索引函数`@`，对一个列表使用索引函数，将返回索引（初始下标为0）处的值，如果没有指定的索引，那么就返回None。

   *示例：*

   ```
   a => [1, 2, 3]
   @ a, 2           // 返回3
   a @ 2            // 人类友好的书写方式，也返回3，该表达式的理解将在下面四则运算一阶中介绍
   ```

   索隐函数也可以接受三个参数，当其接受三个参数时，表示为指定索引赋值。还是用上面的列表，下面的例子则说明了这种操作：

   ```
   @ a, 2, 666      // a为[1, 2, 666]
   @ a, 0, 123      // a为[123, 2, 666]
   ```

   不过要注意，在这种情况下无法使用人类友好的书写方式

2. 插入函数 ->，对一个列表使用插入函数，将在列表指定索引处插入指定的值，原来的值依次向后挪动。

   *示例：*

   ```
   a => [1, 2, 3]
   -> a, 3, 6      // a为[1, 2, 3, 6]
   -> a, 1, 34     // a为[1, 34, 2, 3, 6]
   ```

3. 移除函数 <-，对一个列表使用移除函数，将移除指定索引处的值，后面的值（如果有）则依次向前挪动。

   *示例：*

   ```
   a => [1, 2, 3, 4, 5, 6]
   <- a, 2         // a为[1, 2, 4, 5, 6]
   -> a, 2, 666    // a为[1, 2, 666, 4, 5, 6]
   <- a, 0         // a为[2, 666, 4, 5, 6]
   ```



##### 字符串

字符串是另一个常用的特殊类型，字符串类型为str，并由双引号所包括。

*示例：*

- "This is a string."

- "Hello World!!"

##### 字符串上的运算

字符串在底层上使用列表来实现，所以字符串的运算与列表的运算大致相同。



##### 元组

元组和数学中的“有序对”的概念类似，它可以包括若干个相同类型的数据，但是其数量和类型在定以后不可以变化。元组类型为tuple，元组由`[]`所包括。下面的元组都是合法的：

- (1, 2)
- (3.44i0.0, 2.98i8, 7i2.9)
- ("string a", "string b")
- ([1, 2, 3], [3, 4], [1])

##### 元组上的运算

元组的运算列表类似，但是由于元组的数量和类型不能改变，所以添加运算符`->`和移除运算符`<-`不能作用域元组。下面的操作是非法的：

- 向元组中添加元素

  ```
  a = (1, 2)
  -> a, 1, 4        // 不能获得正确的结果
  ```

- 移除元素

  ```
  a =(1, 2, 3, 4)
  <- a, 2          // 出错，因为元组的元素数量不可变
  ```


##### 字典

字典提供了一种“键-值”对应的数据表示方法，例如我们可以使用字典来表示json数据。除此之外，字典也可以被当做结构体来使用，进一步，也可以为实现对象提供帮助。有趣的是，在FA语言中，暂时没有实现字典，取而代之的是使用列表和元组来实现。也就是如果我们要定义一个包含名字和年龄的字典，我们可以这样做：

```
tom => [ ("name", "Tom"), ("age", 26)]
john => [("name", "John"), ("age", 34)]
```



### <span id="#variable_and_function">变量与函数</span>

#### 变量与函数的定义

- 在函数式语言中，变量也是函数（XD），所以定义变量和定义函数有着几乎相同的形式：

  ```
  <name> => <val>  // 定义变量
  <name> <type> param1[, <type> param2[, <type> param3]] => <func> // 定义函数，其中param1，param2和param3是形参。
  ```

  在FA语言中，函数必须有至少一个参数。如果确实需要定义一个无参数的函数，那么可以把`None`作为实参来传递。而在定义的时候，形参必不可少。

- 如果需要定义一个很长的函数，例如在函数中有多步操作，那么上面的函数定义是行不通的，我们要采用下面的定义方式：

  ```
      <name> <type> param1[, <type> param2[, <type> param3]] => { <step1>， <step2>，  ... }
  ```

  这种方式定义，可以跨越多行，也就是说，函数的定义将从`{}`开始，直到`}`结束。

- 函数的函数的返回值则取决于在函数中最后一步计算的结果，也就是说你无法在函数中显式地返回。函数返回值的类型将自动进行推导。

- 当一个函数返回后，其值将保存在全局变量`__ANS`中。

- 在函数内部，也可以定义函数，也就是说，函数的定义是可以嵌套的。只不过，定义在函数内部的函数，在函数外是无效的。

  *示例：*

  ```
  area_of_circle r => 3.14 * r ** 2  // 定义了求圆的面积的函数
  pi => 3.14  // 定义了变量pi
  vol_of_cylinder r, h => area_ofcircle r * h // 定义了求圆柱体积的函数
  ```

  实际上，变量的值也可以是一个函数，例如在上面的定义之后，我们可以做如下的定义：

  ```
  s => area_of_circle
  ```

  这样，`s`和`area_of_circle`就执行相同的动作，也就是虽然名字不同，但是它们两个还是相同的东西。

- 函数的类型为`function`，这在将函数作为参数传递时很有用。

在FA语言中，函数虽然在使用的时候看起来像是多个东西组合到一起的，但是实际上函数在调用的时候，函数和它的实参是一个整体。



#### 变量和函数的使用

- 变量在语句中可以直接使用。

- 函数的使用（调用）的形式与其定义类似。例如我们定义了二元函数`add`：

  ```
  add a, b => a + b
  ```

  那么在使用（调用）的时候，就使用下面的形式：

  ```
  add 1, 2    // 返回值为3
  ```

  在函数调用时，解释器将自动判断传入的参数的类型。

- 函数也可以使用另一种调用方式：

  ```
  <param1> <op> <param2>
  ```

  这种调用方式被称为人类可读写法。这种写法主要是针对二元函数的。将在下一节作具体讨论。



#### ~~原生语法和人类可读语法~~

由于全局变量`__ANS`，以及复合语句和间隔符的存在，我们可以使用人类可读的语法。

所谓人类可读的语法，是针对二元函数的一种辅助写法。语法如下：

```
<param1> <bi-op> <param2>
```

*示例：*

```
1 + 2        // 返回 3
```



我们可以这样来理解这种语法：`<param1>`被当做函数来计算，计算结果保存在`__ANS`中，然后再执行函数`+`。

在执行`+`函数时，解释器判断其参数数量少于两个，那么就把`__ANS`作为第一个参数，其余的以此类推，再进行计算，也就是相当于

```
<op> __ANS, <param2>
```

那么整体来看的话，就是

```
<func1: 1> <func2: +> <func3: 2>
```



那么这样就延伸出另一个语法特点

```
<func1 and its params> <func2 and its params> <func3 and params>
```

在这种情况下，`1 - (+ 2, 3) - 4`该如何处理呢？

它是`1 - ( 2 + 3) - 4`。



**注意：**

`1 - + 2, 3 - 4`的写法是有问题的，因为在优先级上，`,`要低于该语句中的所有函数。所以在执行的时候是按照`(1 - + 2), (3 - 4)`来执行的。而这样会有问题，因为`- + 2`是一个非法的语句。



#### calc函数

为了解决人类可读语法的一些不方便之初，引入了calc内建函数来对人类可读的表达式进行求值。calc接受一个字符串参数，在字符串中可以使用任何数据类型，也可以使用变量或函数名。

*示例：*

```
a => int calc "1 + 3 * 9.3 - 4"   // 返回24
```



#### <span id="basic_operations">算数运算</span>

在这一节中，介绍一些基本的运算，包括四则运算、幂和括号

##### <span id="four_operations">四则运算</span>

四则运算的基本操作在[形式](#grammar_form)一节中稍微提到过了，使用下面的形式来执行：

```
<op> <param1>, <param2>
```



##### 幂

幂的运算符为`**`，即两个一起的星号。幂的优先级大于`*`和`/`。

下面举一些例子：

- 3<sup>4

  ```
  ** 3, 4
  ```

- 5<sup>4.5

  ```
  ** 5, 4.5
  ```

- (3 * 9)<sup>(4/5)

  ```
  ** (* 3, 9), (/ 4, 5)
  ```



#### 布尔运算

布尔运算主要面向布尔类型，如果操作数不是布尔类型，那么将首先将其转换为布尔类型，再进行运算。布尔运算的结果为布尔类型的数据，也就是将返回`true`或`false`。

- **非**运算

  ```
  not <val>
  // 或
  ! <val>
  ```

  非运算返回与`<val>`相反的值，也就是说如果`<val>`为`true`则`false`，反之返回`true`。

  *示例：*

  ```
  not true    // 返回false
  not false   // 返回true
  ```

- **与**运算

  ``` 
  and <val1>, <val2>
  // 或
  <val1> and <val2>
  // 或
  && <val1>, <val2>
  // 或
  <val1> && <val2>
  ```

  *示例：*

  ```
  and true, false    // 返回false
  and false, false   // 返回false
  and true, true     // 返回true
  true and false     // 返回false
  true and true      // 返回true
  ```

- **或**运算

  ```
  or <val1>, <val2>
  // 或
  <val1> or <val2>
  // 或
  || <val1>, <val2>
  // 或
  <val1> || <val2>
  ```

  *示例：*

  ```
  or true, true      // 返回true
  or true, false     // 返回true
  or false, false    // 返回false
  false or false     // 返回false
  true or false      // 返回true
  ```

- **异或**运算

  ```
  xor <val1>, <val2>
  // 或
  <val1> xor <val2>
  // 或
  ^ <val1>, <val2>
  // 或
  <val1> ^ <val2>
  ```

  *示例：*

  ```
  xor true, false    // 返回true
  xor false, true    // 返回true
  xor false, false   // 返回false
  xor true, true     // 返回false
  ```


#### 关系运算

关系运算返回布尔类型。



- 大于

  ```
  > <val1>, <val2>
  // 或
  <val1> > <val2>
  ```

- 小于

  ```
  < <val1>, <val2>
  // 或
  <val1> < <val2>
  ```

- 等于

  ```
  == <val1>, <val2>
  // 或
  <val1> == <val2>
  ```

- 大于等于

  ```
  >= <val1>, <val2>
  // 或
  <val1> >= <val2>
  ```

- 小于等于

  ```
  <= <val1>, <val2>
  // 或
  <val1> <= <val2>
  ```



#### 括号

括号可以用来改变优先级，在一个函数中，括号内的内容总是被保证先计算的。

*示例：*

```
1 - （2 - （3 + 4）* 4）
```



#### 函数的缺省写法

函数可以使用缺省写法，即省略参数的情况。在这种情况下，可以省略函数的第一个参数，在执行时，以`__ANS`的内容作为第一个参数来执行。

*示例：*

```
4           // 刷新__ANS，使之变为4
+ 3         // 返回7
bool        // 返回true
int         // 返回1
* 6         // 返回6
** 2        // 返回36
```

不过这种写法有一个特例，就是作为参数传递时。这种写法也可以作为参数来传递。



### 优先级

1. 内部的括号总是被优先计算，也就是说，括号拥有最高的优先级。
2. 单目运算的优先级大于双目运算的优先级。
3. 在双目运算中，优先级次序为：幂＞ */ ＞+-＞双目布尔运算。
4. 在同等级的运算中，运算次序为从左到右。